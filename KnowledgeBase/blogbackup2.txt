http://blog.csdn.net/unix21/article/details/8466440
http://man.linuxde.net/ld
http://blog.csdn.net/ayu_ag/article/details/50737209
程序并不是从main函数开始执行的，gcc -o main main.c时，默认会连接libc.so(可以指定-nodefaultlib, -nostdlib取消连接)，并且会添加一个启动代码_start函数(可以指定-nodefaultlib, -nostdlib不添加启动代码)，用于初始化，并提供main函数的argc, argv等参数，_start函数中会调用main函数。

readelf -h main ｜ grep Entry可以看到：
  Entry point address:               0x4003d0
程序的入口地址是0x4003d0，也就是_start函数的地址，程序装载到内存后，从0x4003d0(_start)开始执行。


那么，我不想执行_start函数呢，可以通过ld的参数-e指定入口函数，使用gcc -o main mian.c -Wl,-ehello编译，-Wl用于指定后面的参数是给ld的，-e指定入口函数是hello。

https://stackoverflow.com/questions/14314021/why-linux-gnu-linker-chose-address-0x400000
The start address is usually set by a linker script.

For example, on GNU/Linux, looking at /usr/lib/ldscripts/elf_x86_64.x we see:

...
PROVIDE (__executable_start = SEGMENT_START("text-segment", 0x400000)); \
    . = SEGMENT_START("text-segment", 0x400000) + SIZEOF_HEADERS;

http://blog.csdn.net/qq_16209077/article/details/51975605
Linux系统给每个进程分配了4GB的空间，其中 0xC0000000到0xFFFFFFFF 这个地址段是留给系统使用的，主要用于系统（linux 内核)和进程通信和交换数据，   用户可以使用3GB的空间从(0x00000000-0xBFFFFFFF).

http://blog.csdn.net/anonymalias/article/details/51784803
下面是进程地址空间的简易结构图：每个可执行文件生成的时候，虚拟地址空间都会从0x400000开始分配(64位)，32位为0x8048000。 

https://www.jianshu.com/p/eb39eac9d82e
该入口是由ld链接器默认的链接脚本指定的，当然用户也可以通过参数进行设定。_start由汇编代码实现。大致用如下伪代码表示：
void _start()
{
　　%ebp = 0;
　　int argc = pop from stack
　　char ** argv = top of stack;
　　__libc_start_main(main, argc, argv, __libc_csu_init, __linc_csu_fini,
　　edx, top of stack);
}

作者：popsheng
链接：https://www.jianshu.com/p/eb39eac9d82e
來源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


https://www.linuxidc.com/Linux/2011-08/41869p2.htm
可以从glibc的源代码目录中sysdeps/generic/libc-start.c看到，__libc_start_main的原型为：

extern int BP_SYM (__libc_start_main) (int (*main) (int, char **, char **),  
        int argc,  
        char *__unbounded *__unbounded ubp_av,  
        void (*init) (void),  
        void (*fini) (void),  
        void (*rtld_fini) (void),  
        void *__unbounded stack_end)  
__attribute__ ((noreturn));  


这些值应该是由内核设置的。

当我们在shell里面调用一个可执行文件，linux会进行以下操作：

（1）shell调用系统调用“execve”，带上参数信息argc/argv。

（2）内核系统调用的handler获得控制，并处理系统调用。在内核代码中，execve对应的handler是"sys_execve"。在x86中，用户模式的应用会使用以下寄存器向内核传递一些必要的参数：

ebx： 指向程序名的指针
ecx：参数数组指针
edx：环境变量数组指针
（3）linux然后调用通用的execve内核系统调用handler，do_execve。该调用建立一个数据结构，并将用户空间的数据拷贝到内核空间，然后调用search_binary_handler。Linux能够同时支持多种可执行文件的格式，比如a.out和ELF。为了实现这种功能，linux利用一个“struct linux_binfmt”数据结构，存储各种二进制格式的加载器的函数指针。search_binary_handler查询并调用合适的加载器（本例子中是load_elf_binary）。加载器首先建立一个数据结构用来存储ELF文件映像。然后，再建立一个内核数据结构，存���相关信息，包括代码大小，数据段起始地址，栈起始地址，等等。然后，为该程序分配用户模式的页表，并将参数以及环境变量拷贝到页面地址中。最后，create_elf_tables()函数将参数指针，环境变量数组指针压入用户模式的栈；start_thread()函数启动_start开始的进程代码。
      当_start标号所在的汇编指令开始执行时，函数的栈帧如下所示：

Stack Top           -------------  
                            argc  
                        -------------  
                            argv pointer  
                        -------------  
                            env pointer  
                        -------------   
然后，这些信息传递给_start函数：
pop %esi                  //获得argc

move %esp, %ecx    //获得argv

当这些信息传递给_start函数以后，_start函数通过将esp的低4位清0（即16字节对齐）来设置我们的主程序的栈的起始地址。

//注：这些代码所在的文件是crtbegin.o, crtend.o, gcrt1.o。



6. 总结

（1）内核加载可执行文件，并建立text/data/bss/stack。此外，内核为参数和环境变量分配页，并将它们压入用户模式栈。
（2）GCC通过crtbegin.o/crtend.o/gcrt1.o来建立程序。另外的默认库默认是动态链接的。可执行文件的开始地址是_start的地址。

（3）控制传递给_start以后，_start从由内核设置的栈中获取参数和环境变量信息，然后调用__libc_start_main。

（4）__libc_start_main初始化必要的数据结构，尤其是C库（比如malloc）和线程环境，然后调用用户的main函数。值得注意的是，__libc_start_main认为main

函数的签名是:

int main(int argc,  char ** argv, char ** env)。

（5）main函数的返回值由__libc_start_main接收，并传递给exit。


http://abcdxyzk.github.io/blog/2012/11/23/assembly-args/
r8,r9

http://blog.csdn.net/langchibi_zhou/article/details/5744922

https://www.mtyun.com/library/linker
第三列表示变量的名字，这里我们看到局部的静态变量名字被编译器修改为 s_a.1597，我们应该能猜得到编译器这么做的原因。s_a 是一个局部静态变量，作用域限制在定义它的代码块中，所以我们可以在不同的作用域中声明相同名字的局部静态变量，比如我们可以在sum函数中声明另外一个 s_a。但是我们上面提过，局部静态变量属于全局变量的范畴，它是存在于程序运行的整个生命周期的，所以为了支持这个功能，编译器对这种局部的静态变量名字加了一个后缀以便标识不同的局部静态变量。

main对应的指令就是我们自己的main函数了，__libc_csu_init接着会调用_init的指令，然后会调用__do_global_ctors_aux这个 C++ 程序员都应该熟悉的 symbol 对应的指令，__do_global_ctors_aux对应的指令会进行所有的全局变量初始化，或者 C++ 中的全局对象构造等操作。


http://blog.csdn.net/absurd/article/details/928972
共享库的初始化和~初始化函数分析


https://www.codeproject.com/Articles/9426/Need-for-Rebasing-a-DLL
The loader has to iterate through the relocation section and modify a lot of the module's code. This produces a major performance hit and can really hurt an application's initialization time.
As the loader writes to the module's code pages, the system's copy-on-write mechanism forces these pages to be backed by the system's paging file.


http://blog.csdn.net/gatieme/article/details/51628257
http://blog.csdn.net/A1342772/article/details/77688148
https://eli.thegreenplace.net/2011/08/25/load-time-relocation-of-shared-libraries/
http://www.cnblogs.com/catch/p/3857964.html


gcc在编译时，除非显示的使用static标签，否则所有程序的链接都是动态链接的，也就是说需要解释器。由此可见，我们的程序在被内核加载到内存，内核跳到用户空间后并不是执行目标程序的，而是先把控制权交到用户空间的解释器，由解释器加载运行用户程序所需要的动态库（比如libc等等），然后控制权才会转移到用户程序。

动态链接器执行在ELF文件中标记为.init的节的代码，进行程序运行的初始化。 
动态链接器把控制传递给程序，从ELF文件头部中定义的程序进入点(main)开始执行。在a.out格式和ELF格式中，程序进入点的值是显式存在的，而在COFF格式中则是由规范隐含定义。

http://gotowqj.iteye.com/blog/1926771
rpath

https://greek0.net/elf.html
https://www.cnblogs.com/xmphoenix/archive/2011/10/23/2221879.html
elf format
上面类型为PHDR的segment，用来包含程序头表本身。
