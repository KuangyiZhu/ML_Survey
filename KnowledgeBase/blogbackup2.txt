http://blog.csdn.net/unix21/article/details/8466440
http://man.linuxde.net/ld
http://blog.csdn.net/ayu_ag/article/details/50737209
程序并不是从main函数开始执行的，gcc -o main main.c时，默认会连接libc.so(可以指定-nodefaultlib, -nostdlib取消连接)，并且会添加一个启动代码_start函数(可以指定-nodefaultlib, -nostdlib不添加启动代码)，用于初始化，并提供main函数的argc, argv等参数，_start函数中会调用main函数。

readelf -h main ｜ grep Entry可以看到：
  Entry point address:               0x4003d0
程序的入口地址是0x4003d0，也就是_start函数的地址，程序装载到内存后，从0x4003d0(_start)开始执行。


那么，我不想执行_start函数呢，可以通过ld的参数-e指定入口函数，使用gcc -o main mian.c -Wl,-ehello编译，-Wl用于指定后面的参数是给ld的，-e指定入口函数是hello。

https://stackoverflow.com/questions/14314021/why-linux-gnu-linker-chose-address-0x400000
The start address is usually set by a linker script.

For example, on GNU/Linux, looking at /usr/lib/ldscripts/elf_x86_64.x we see:

...
PROVIDE (__executable_start = SEGMENT_START("text-segment", 0x400000)); \
    . = SEGMENT_START("text-segment", 0x400000) + SIZEOF_HEADERS;

http://blog.csdn.net/qq_16209077/article/details/51975605
Linux系统给每个进程分配了4GB的空间，其中 0xC0000000到0xFFFFFFFF 这个地址段是留给系统使用的，主要用于系统（linux 内核)和进程通信和交换数据，   用户可以使用3GB的空间从(0x00000000-0xBFFFFFFF).

http://blog.csdn.net/anonymalias/article/details/51784803
下面是进程地址空间的简易结构图：每个可执行文件生成的时候，虚拟地址空间都会从0x400000开始分配(64位)，32位为0x8048000。 

https://www.jianshu.com/p/eb39eac9d82e
该入口是由ld链接器默认的链接脚本指定的，当然用户也可以通过参数进行设定。_start由汇编代码实现。大致用如下伪代码表示：
void _start()
{
　　%ebp = 0;
　　int argc = pop from stack
　　char ** argv = top of stack;
　　__libc_start_main(main, argc, argv, __libc_csu_init, __linc_csu_fini,
　　edx, top of stack);
}

作者：popsheng
链接：https://www.jianshu.com/p/eb39eac9d82e
來源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

http://abcdxyzk.github.io/blog/2012/11/23/assembly-args/
r8,r9
